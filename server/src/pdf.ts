// server/src/pdf.ts (UPDATED)

import PDFDocument from 'pdfkit';
import type { Response } from 'express';
import { marked } from 'marked';

// --- Helper function for sanitizing filenames ---
function sanitizeFilename(filename: string): string {
  return filename.replace(/[\/\\]/g, '').replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 100);
}

/**
 * Creates a styled PDF from a Markdown string and streams it to the client.
 * @param res The Express Response object.
 * @param title The document title.
 * @param markdownContent The Markdown content generated by the AI.
 */
export function streamTextAsPDF(res: Response, title: string, markdownContent: string) {
  const safeFilename = sanitizeFilename(title);

  res.setHeader('Content-Type', 'application/pdf');
  res.setHeader('Content-Disposition', `attachment; filename="${safeFilename || 'document'}.pdf"`);

  const doc = new PDFDocument({ margin: 50 });
  doc.pipe(res);

  // --- Register custom fonts (optional, but highly recommended for styling) ---
  // Make sure you have these .ttf files in a folder, e.g., server/assets/
  // doc.registerFont('regular', 'path/to/your/fonts/Roboto-Regular.ttf');
  // doc.registerFont('bold', 'path/to/your/fonts/Roboto-Bold.ttf');
  // doc.font('regular');

  // --- Parse the Markdown content into tokens ---
  const tokens = marked.lexer(markdownContent);

  // --- Loop through tokens and apply PDF styling ---
  for (const token of tokens) {
    switch (token.type) {
      case 'heading':
        doc.moveDown(0.5);
        doc
          .fontSize(token.depth === 1 ? 20 : token.depth === 2 ? 16 : 14) // Larger font for H1/H2
          // .font('bold')
          .text(token.text, { paragraphGap: 5 });
        doc.moveDown(0.5);
        break;

      case 'paragraph':
        // Handle inline elements like bold text within a paragraph
        if ('tokens' in token && token.tokens) {
          const parts = token.tokens;
          let currentText = '';
          for (const part of parts) {
            // Check for the 'text' property
            if (!('text' in part)) {
              continue; // Skip tokens without a text property, like 'br'
            }
            if (part.type === 'strong') {
              doc.text(currentText, { continued: true }); // Print preceding text
              doc/*.font('bold')*/.text(part.text, { continued: true }); // Print bold text
              // doc.font('regular'); // Switch back to regular
              currentText = ''; // Reset
            } else if (part.type === 'em') {
              // You can add italic handling here
              doc.text(currentText, { continued: true });
              // doc.font('italic').text(part.text, { continued: true });
              // doc.font('regular');
              currentText = '';
            } else {
              currentText += part.text;
            }
          }
          doc.text(currentText, { paragraphGap: 8 }); // Print remaining text
        }
        break;

      case 'list':
        doc.moveDown(0.5);
        const listItems = token.items.map((item: { tokens: any[]; }) => {
          // Flatten nested tokens to get the text
          return item.tokens.map(t => 'text' in t ? t.text : '').join('');
        });
        doc.list(listItems, { bulletRadius: 2.5, textIndent: 10, paragraphGap: 5 });
        doc.moveDown(0.5);
        break;

      case 'space':
        // Adds vertical space between elements
        doc.moveDown();
        break;

      default:
        // For other token types like blockquotes, code blocks, etc.
        // You can add more handlers here.
        break;
    }
  }

  doc.end();
}